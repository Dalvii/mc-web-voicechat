<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8" />
    <title>Appel vocal WebRTC - Spatialisation basique</title>
</head>

<body>
    <h1>WebRTC + Spatialisation Minecraft</h1>

    <div>
        <label for="pseudo">Pseudo (identique à votre pseudo Minecraft) :</label>
        <input type="text" id="pseudo" placeholder="MonPseudoMC" />
        <button id="connectBtn">Se connecter</button>
    </div>

    <div style="margin-top: 20px;">
        <button id="startAudioBtn" disabled>Activer mon micro</button>
        <button id="testVolumeBtn">Test Volume -</button>
    </div>

    <script>
        // ------------------------------------------------
        // Variables globales
        // ------------------------------------------------
        let ws;                    // WebSocket
        let localStream = null;    // Flux audio local (micro)
        let peers = {};            // peerId -> RTCPeerConnection
        let audioNodes = {};       // peerId -> { source, panner, gain, ... }
        let positions = {};        // playerName -> { x, y, z, yaw, pitch }
        let localPseudo = "";      // Pseudo local
        let connected = false;     // Indique si on est connecté au WS

        // AudioContext global
        let audioContext;

        // Config basique RTC
        const rtcConfig = {
            iceServers: []
        };

        // Sélection des éléments
        const pseudoInput = document.getElementById("pseudo");
        const connectBtn = document.getElementById("connectBtn");
        const startAudioBtn = document.getElementById("startAudioBtn");
        const testVolumeBtn = document.getElementById("testVolumeBtn");

        // ------------------------------------------------
        // Connexion WebSocket
        // ------------------------------------------------
        function connectWebSocket() {
            // Adaptez l'URL en fonction de votre serveur
            ws = new WebSocket("ws://192.168.1.27:25566");

            ws.onopen = () => {
                console.log("Connecté au serveur WebSocket.");
                connected = true;
                startAudioBtn.disabled = false;
            };

            ws.onmessage = async (event) => {
                let data;
                try {
                    data = JSON.parse(event.data);
                } catch (e) {
                    console.warn("Message non JSON :", event.data);
                    return;
                }

                const { type, from, to, payload } = data;

                // Cas particulier : message de position
                if (type === "pos") {
                    handlePosition(data);
                    return;
                }

                // Sinon, on gère la signalisation WebRTC
                // On ignore si le message n’est pas pour nous
                if (to && to !== localPseudo) return;

                switch (type) {
                    case "join":
                        handleJoin(from);
                        break;
                    case "offer":
                        handleOffer(from, payload);
                        break;
                    case "answer":
                        handleAnswer(from, payload);
                        break;
                    case "candidate":
                        handleCandidate(from, payload);
                        break;
                    default:
                        console.warn("Type de message inconnu :", type);
                }
            };

            ws.onclose = () => {
                console.log("Déconnecté du serveur WebSocket.");
                connected = false;
            };

            ws.onerror = (err) => {
                console.error("Erreur WebSocket :", err);
            };
        }

        // Envoi de message JSON via WS
        function sendMessage(msg) {
            if (ws && connected) {
                ws.send(JSON.stringify(msg));
            }
        }

        // ------------------------------------------------
        // Gestion positions (Minecraft)
        // ------------------------------------------------
        /**
         * Reçoit un message 
         *    {
         *      "type": "pos",
         *      "player": "Pseudo",
         *      "payload": { "x":..., "y":..., "z":..., "yaw":..., "pitch":... }
         *    }
         */
        function handlePosition(data) {
            const { player, payload } = data;
            if (!player || !payload) return;

            // On stocke x, y, z, yaw, pitch
            positions[player] = {
                x: payload.x,
                y: payload.y,
                z: payload.z,
                yaw: payload.yaw,
                pitch: payload.pitch
            };

            console.log("Position reçue pour", player, positions[player]);

            // Mettre à jour la spatialisation audio pour tout le monde
            updateAllSpatialization();
        }

        testVolumeBtn.onclick = () => {
            // Supposez qu'on a un flux distant avec peerId = "Test"
            // (exemple purement illustratif)
            const peerId = "Test";
            const node = audioNodes[peerId];
            if (!node) return;

            node.gain.gain.value -= 0.1;
            if (node.gain.gain.value < 0) node.gain.gain.value = 0;
            console.log("Nouveau gain =", node.gain.gain.value);
        };

        /**
         * Met à jour le volume (gain) et le pan stéréo pour chaque flux audio reçu,
         * en tenant compte de la distance ET de l'orientation du joueur local.
         *
         * - On calcule d'abord l'angle "absolu" via atan2(dz, dx).
         * - Puis on soustrait la yaw du joueur local pour connaître la position relative
         *   par rapport à son champ de vision (ex: s'il regarde le nord, tout ce qui
         *   est au nord lui arrive "en face").
         */
        function updateAllSpatialization() {
            // Récupère la position/orientation du joueur local
            const localPos = positions[localPseudo];
            if (!localPos) return; // on ne connaît pas encore la position/orientation locale

            // Yaw local en radians (Minecraft a 0 = Sud, +90 = Ouest, etc.)
            // On applique une correction pour que "yaw=0" pointe vers +Z
            // Par exemple : on inverse le sens et on ajoute π/2 si nécessaire.
            const mcYawRad = (localPos.yaw || 0) * Math.PI / 180;
            // Exemple de correction :
            const localYawRad = -mcYawRad + Math.PI / 2;

            for (let peerId in audioNodes) {
                if (!positions[peerId]) continue;

                const otherPos = positions[peerId];
                // Distance horizontale
                const dx = otherPos.x - localPos.x;
                const dz = otherPos.z - localPos.z;
                const distance = Math.sqrt(dx * dx + dz * dz);

                // Volume en fonction de la distance
                const distanceMax = 20;
                let volume = 1 - (distance / distanceMax);
                if (volume < 0) volume = 0;

                // Angle absolu de la source (axe X => angle=0)
                let absoluteAngle = Math.atan2(dz, dx);

                // Angle relatif par rapport au yaw du joueur local
                let relativeAngle = absoluteAngle - localYawRad;

                // Ramener cet angle dans [-π, +π]
                while (relativeAngle > Math.PI) relativeAngle -= 2 * Math.PI;
                while (relativeAngle < -Math.PI) relativeAngle += 2 * Math.PI;

                // Conversion en pan stéréo [-1, +1]
                let pan = relativeAngle / Math.PI;
                if (pan < -1) pan = -1;
                if (pan > 1) pan = 1;

                // Application aux nodes
                audioNodes[peerId].gain.gain.value = volume;
                audioNodes[peerId].panner.pan.value = pan;

                console.log(
                    `Peer=${peerId}`,
                    `Dist=${distance.toFixed(2)}`,
                    `Vol=${volume.toFixed(2)}`,
                    `YawLocal=${(mcYawRad * 180 / Math.PI).toFixed(1)}`,
                    `AbsAngle=${(absoluteAngle * 180 / Math.PI).toFixed(1)}`,
                    `RelAngle=${(relativeAngle * 180 / Math.PI).toFixed(1)}`,
                    `Pan=${pan.toFixed(2)}`
                );
            }
        }


        // ------------------------------------------------
        // WebRTC : fonctions d’aide
        // ------------------------------------------------
        function getOrCreatePeerConnection(peerId) {
            if (peers[peerId]) {
                return peers[peerId];
            }

            const pc = new RTCPeerConnection(rtcConfig);

            pc.onicecandidate = (event) => {
                if (event.candidate) {
                    sendMessage({
                        type: "candidate",
                        from: localPseudo,
                        to: peerId,
                        payload: event.candidate
                    });
                }
            };

            pc.ontrack = (event) => {
                console.log("ontrack from", peerId);
                const remoteStream = event.streams[0];
                createSpatialAudioNode(peerId, remoteStream);
            };

            // Si on a déjà le flux local, on l’ajoute
            if (localStream) {
                localStream.getTracks().forEach(track => {
                    pc.addTrack(track, localStream);
                });
            }

            peers[peerId] = pc;
            return pc;
        }

        // Crée la "chaîne" audio pour spatialiser : Stream -> SourceNode -> StereoPanner -> Gain -> destination
        function createSpatialAudioNode(peerId, remoteStream) {
            // Optionnel : On peut créer un <audio> (caché) pour debug
            let audioElem = document.getElementById("audio-" + peerId);
            if (!audioElem) {
                audioElem = document.createElement("audio");
                audioElem.id = "audio-" + peerId;
                audioElem.autoplay = false; // on gère via AudioContext
                audioElem.style.display = "none";
                document.body.appendChild(audioElem);
            }
            audioElem.srcObject = remoteStream;

            // Chaîne audio
            const sourceNode = audioContext.createMediaStreamSource(remoteStream);
            const pannerNode = audioContext.createStereoPanner();
            const gainNode = audioContext.createGain();

            // Brancher les noeuds : source -> panner -> gain -> destination
            sourceNode.connect(pannerNode).connect(gainNode).connect(audioContext.destination);

            // Stockage pour ajuster volume/pan en fonction des positions
            audioNodes[peerId] = {
                source: sourceNode,
                panner: pannerNode,
                gain: gainNode
            };

            // Initialiser la spatialisation s'il y a déjà les positions
            updateAllSpatialization();
        }

        // ------------------------------------------------
        // Handlers signalisation
        // ------------------------------------------------
        function handleJoin(peerId) {
            console.log("handleJoin from", peerId);
            const pc = getOrCreatePeerConnection(peerId);

            pc.createOffer()
                .then(offer => pc.setLocalDescription(offer))
                .then(() => {
                    sendMessage({
                        type: "offer",
                        from: localPseudo,
                        to: peerId,
                        payload: pc.localDescription
                    });
                })
                .catch(console.error);
        }

        function handleOffer(peerId, offer) {
            console.log("handleOffer from", peerId);
            const pc = getOrCreatePeerConnection(peerId);

            pc.setRemoteDescription(new RTCSessionDescription(offer))
                .then(() => pc.createAnswer())
                .then(answer => pc.setLocalDescription(answer))
                .then(() => {
                    sendMessage({
                        type: "answer",
                        from: localPseudo,
                        to: peerId,
                        payload: pc.localDescription
                    });
                })
                .catch(console.error);
        }

        function handleAnswer(peerId, answer) {
            console.log("handleAnswer from", peerId);
            const pc = getOrCreatePeerConnection(peerId);
            pc.setRemoteDescription(new RTCSessionDescription(answer)).catch(console.error);
        }

        function handleCandidate(peerId, candidate) {
            console.log("handleCandidate from", peerId);
            const pc = getOrCreatePeerConnection(peerId);
            pc.addIceCandidate(new RTCIceCandidate(candidate)).catch(console.error);
        }

        // ------------------------------------------------
        // Boutons / Actions UI
        // ------------------------------------------------
        connectBtn.onclick = () => {
            localPseudo = pseudoInput.value.trim();
            if (!localPseudo) {
                alert("Veuillez saisir votre pseudo (le même que Minecraft).");
                return;
            }

            // Créer / reprendre un contexte audio
            audioContext = new AudioContext();
            audioContext.resume();

            // Se connecter au serveur WS
            connectWebSocket();

            // Après un court délai, on envoie un 'join'
            setTimeout(() => {
                sendMessage({
                    type: "join",
                    from: localPseudo,
                    to: null,
                    payload: {}
                });
            }, 500);

            connectBtn.disabled = true;
            pseudoInput.disabled = true;
        };

        startAudioBtn.onclick = async () => {
            try {
                localStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
                console.log("Micro capturé.");

                // Ajouter ce flux à chaque PeerConnection existante
                Object.keys(peers).forEach(peerId => {
                    const pc = peers[peerId];
                    localStream.getTracks().forEach(track => {
                        pc.addTrack(track, localStream);
                    });
                });

                // Optionnel : relancer une offre pour envoyer le flux
                Object.keys(peers).forEach(peerId => {
                    const pc = peers[peerId];
                    pc.createOffer()
                        .then(offer => pc.setLocalDescription(offer))
                        .then(() => {
                            sendMessage({
                                type: "offer",
                                from: localPseudo,
                                to: peerId,
                                payload: pc.localDescription
                            });
                        })
                        .catch(console.error);
                });

                startAudioBtn.disabled = true;
            } catch (err) {
                console.error("Erreur getUserMedia :", err);
                alert("Impossible d'accéder au micro.");
            }
        };
    </script>
</body>

</html>